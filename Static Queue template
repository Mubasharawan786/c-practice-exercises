#ifndef INTQUEUE_H
#define INTQUEUE_H
#include<iostream>
using namespace std;
template<class T>
class IntQueue 
{
    private:
    T*queueArray;
    T queueSize;
    T front;
    T rear;
    T numItems;
    public:
    //constructor
    IntQueue(T);
    //copy constructor
    IntQueue(const  IntQueue&);
    //Destructor
    //constructor
    ~IntQueue( );
    //Queue operations
    void enqueue(T);
    void dequeue(T&);
    bool IsEmpty()const;
    bool IsFull()const;
    void clear();
};
//constructor defination
  IntQueue::IntQueue(T s)
{
    queueArray=new T[s];
    queueSize=s;
    front=-1;
    rear=-1;
    numItems=0;
}
//copy construtor
  IntQueue::IntQueue(const IntQueue &obj)
{
    queueArray=new T[obj.queueSize];
    queueSize=obj.queueSize;
    front=obj.front;
    rear=obj.rear;
    numItems=obj.numItems;
    for(int count=0;count<obj.queueSize;count++)
    {
        queueArray[count]=obj.queueArray[count];
    }
}     
//Destructor defination
IntQueue::~IntQueue()
{
    delete []queueArray;
}
//Enqueue defination
void IntQueue::enqueue(T num)
{
    if(IsFull())
    {
        cout<<"The queue is full\n";
    }
    else
    {
     rear=(rear+1)%queueSize;
     queueArray[rear]=num;
     numItems++;   
    }
}
//Dequeue defination
void IntQueue::dequeue(T&num)
{
    if(IsEmpty())
    {
        cout<<"The queue is empty\n";
    }
    else
    {
        front=(front+1)%queueSize;
        num=queueArray[front];
        numItems--;
    }
}
//IsEmpty function defination
bool IntQueue::IsEmpty()const
{
    bool status;
    if(numItems)
       status=false;
    else
      status=true;
    return status;    
} 
//IsFull function defination
 bool IntQueue::IsFull()const
{
    bool status;
    if(numItems<queueSize)
       status=false;
    else
      status=true;
    return status;    
}
//clear function defination
void IntQueue::clear()
{
    front= -1;
    rear= -1;
    numItems=0;
}
#endif
